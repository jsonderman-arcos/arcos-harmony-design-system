Default theme viewer
This tree view allows you to explore how the theme object looks like with the default values.
Premium Templates. Start your project with the best templates for admins, dashboards, and more.
ad by MUI

If you want to learn more about how the theme is assembled, take a look at material-ui/style/createTheme.ts, and the related imports which createTheme() uses.

You can play with the documentation theme object in your browser console, as the theme variable is exposed on all the documentation pages.

Please note that the documentation site is using a custom theme (the MUI's organization branding).

Expand all
Use dark theme
breakpoints: Object
direction: "ltr"
components: Object
palette: Object
spacing: f r()
shape: Object
containerQueries: f n()
applyStyles: f n()
unstable_sxConfig: Object
unstable_sx: f ()
mixins: Object
shadows: Array(25)
typography: Object
transitions: Object
zIndex: Object
toRuntimeSource: f i()
alpha: f alpha()
lighten: f lighten()
darken: f darken()


Theming
Customize Material UI with your theme. You can change the colors, the typography and much more.
MUI for enterprise. Save time and reduce risk. Managed open source — backed by maintainers.
ad by MUI

The theme specifies the color of the components, darkness of the surfaces, level of shadow, appropriate opacity of ink elements, etc.

Themes let you apply a consistent tone to your app. It allows you to customize all design aspects of your project in order to meet the specific needs of your business or brand.

To promote greater consistency between apps, light and dark theme types are available to choose from. By default, components use the light theme type.

Theme provider

Material UI components adhere to the library's default theme out of the box. Use ThemeProvider to inject a custom theme into your application.

ThemeProvider relies on the context feature of React to pass the theme down to the components, so you need to make sure that ThemeProvider is a parent of the components you are trying to customize. You can learn more about this in the API section.

Theme configuration variables

Changing the theme configuration variables is the most effective way to match Material UI to your needs. The following sections cover the most important theme variables:

.palette
.typography
.spacing
.breakpoints
.zIndex
.transitions
.components
You can check out the default theme section to view the default theme in full.

Custom variables

When using Material UI's theme with MUI System or any other styling solution, it can be convenient to add additional variables to the theme so you can use them everywhere. For instance:

const theme = createTheme({
  status: {
    danger: orange[500],
  },
});

Copy
vars is an autogenerated field for CSS theme variables. It will throw an error if you try to pass a value to it:

createTheme({
  vars: { ... }, // ❌ error
})

Copy
TypeScript

You have to use module augmentation to add new variables to the Theme and ThemeOptions.

declare module '@mui/material/styles' {
  interface Theme {
    status: {
      danger: string;
    };
  }
  // allow configuration using `createTheme()`
  interface ThemeOptions {
    status?: {
      danger?: string;
    };
  }
}

Copy
<ThemeProvider theme={theme}>
  <CustomCheckbox defaultChecked />
</ThemeProvider>
<ThemeProvider theme={theme}>
  <CustomCheckbox defaultChecked />
</ThemeProvider>
Press Enter to start editing
To add extra variables to the theme.palette, see palette customization.

Theme builder

The community has built great tools to build a theme:

mui-theme-creator: A tool to help design and customize themes for the Material UI component library. Includes basic site templates to show various components and how they are affected by the theme
Material palette generator: The Material palette generator can be used to generate a palette for any color you input.
Accessing the theme in a component

You can access the theme variables inside your functional React components using the useTheme hook:

import { useTheme } from '@mui/material/styles';

function DeepChild() {
  const theme = useTheme();
  return <span>{`spacing ${theme.spacing}`}</span>;
}

Copy
Nesting the theme

You can nest multiple theme providers.

<ThemeProvider theme={outerTheme}>
  <Checkbox defaultChecked />
  <ThemeProvider theme={innerTheme}>
    <Checkbox defaultChecked />
  </ThemeProvider>
</ThemeProvider>
<ThemeProvider theme={outerTheme}>
  <Checkbox defaultChecked />
  <ThemeProvider theme={innerTheme}>
    <Checkbox defaultChecked />
  </ThemeProvider>
</ThemeProvider>
Press Enter to start editing
The inner theme will override the outer theme. You can extend the outer theme by providing a function:

CSS theme variables

To generate CSS variables from the theme, set cssVariables to true in the theme configuration and pass it to the ThemeProvider:

const theme = createTheme({
  cssVariables: true,
});

function App() {
  return <ThemeProvider theme={theme}>...</ThemeProvider>;
}

Copy
This generates a global stylesheet with the CSS theme variables:

:root {
  --mui-palette-primary-main: #1976d2;
  /* ...other variables */
}

Copy
All components under the ThemeProvider will use those CSS theme variables instead of raw values.

Button styles
- color: #1976d2;
+ color: var(--mui-palette-primary-main);

Copy
To learn more about this feature, see the CSS theme variables guide.

API

createTheme(options, ...args) => theme

Generate a theme base on the options received. Then, pass it as a prop to ThemeProvider.

Arguments
options (object): Takes an incomplete theme object and adds the missing parts.
...args (object[]): Deep merge the arguments with the about to be returned theme.
Only the first argument (options) is processed by the createTheme() function. While passing multiple arguments currently works for backward compatibility, this behavior may be removed in future versions. To ensure your code remains forward-compatible, you should manually deep merge the theme objects and pass the result as a single object to createTheme().

import { deepmerge } from '@mui/utils';
import { createTheme } from '@mui/material/styles';

const theme = createTheme(deepmerge(options1, options2));

Copy
Returns
theme (object): A complete, ready-to-use theme object.

Examples
import { createTheme } from '@mui/material/styles';
import { green, purple } from '@mui/material/colors';

const theme = createTheme({
  palette: {
    primary: {
      main: purple[500],
    },
    secondary: {
      main: green[500],
    },
  },
});

Copy
Theme composition: using theme options to define other options
When the value for a theme option is dependent on another theme option, you should compose the theme in steps.

import { createTheme } from '@mui/material/styles';

let theme = createTheme({
  palette: {
    primary: {
      main: '#0052cc',
    },
    secondary: {
      main: '#edf2ff',
    },
  },
});

theme = createTheme(theme, {
  palette: {
    info: {
      main: theme.palette.secondary.main,
    },
  },
});

Copy
Think of creating a theme as a two-step composition process: first, you define the basic design options; then, you'll use these design options to compose other options.

WARNING: theme.vars is a private field used for CSS variables support. Please use another name for a custom object.

Merging className and style props in defaultProps

By default, when a component has defaultProps defined in the theme, props passed to the component override the default props completely.

import { createTheme } from '@mui/material/styles';

const theme = createTheme({
  components: {
    MuiButton: {
      defaultProps: {
        className: 'default-button-class',
        style: { marginTop: 8 },
      },
    },
  },
});

// className will be: "custom-button-class" (default ignored)
// style will be: { color: 'blue' } (default ignored)
<Button className="custom-button-class" style={{ color: 'blue' }}>
  Click me
</Button>;

Copy
You can change this behavior by configuring the theme to merge className and style props instead of replacing them.

To do this, set theme.components.mergeClassNameAndStyle to true:

import { createTheme } from '@mui/material/styles';

const theme = createTheme({
  components: {
    mergeClassNameAndStyle: true,
    MuiButton: {
      defaultProps: {
        className: 'default-button-class',
        style: { marginTop: 8 },
      },
    },
  },
});

Copy
Here's what the example above looks like with this configuration:

// className will be: "default-button-class custom-button-class"
// style will be: { marginTop: 8, color: 'blue' }
<Button className="custom-button-class" style={{ color: 'blue' }}>
  Click me
</Button>

Copy
responsiveFontSizes(theme, options) => theme

Generate responsive typography settings based on the options received.

Arguments
theme (object): The theme object to enhance.
options (object [optional]):
breakpoints (array<string> [optional]): Default to ['sm', 'md', 'lg']. Array of breakpoints (identifiers).
disableAlign (bool [optional]): Default to false. Whether font sizes change slightly so line heights are preserved and align to Material Design's 4px line height grid. This requires a unitless line height in the theme's styles.
factor (number [optional]): Default to 2. This value determines the strength of font size resizing. The higher the value, the less difference there is between font sizes on small screens. The lower the value, the bigger font sizes for small screens. The value must be greater than 1.
variants (array<string> [optional]): Default to all. The typography variants to handle.
Returns
theme (object): The new theme with a responsive typography.

Examples
import { createTheme, responsiveFontSizes } from '@mui/material/styles';

let theme = createTheme();
theme = responsiveFontSizes(theme);

Copy
unstable_createMuiStrictModeTheme(options, ...args) => theme

WARNING: Do not use this method in production.

Generates a theme that reduces the amount of warnings inside React.StrictMode like Warning: findDOMNode is deprecated in StrictMode.

Requirements
Currently unstable_createMuiStrictModeTheme adds no additional requirements.

Arguments
options (object): Takes an incomplete theme object and adds the missing parts.
...args (object[]): Deep merge the arguments with the about to be returned theme.
Returns
theme (object): A complete, ready-to-use theme object.

Examples
import { unstable_createMuiStrictModeTheme } from '@mui/material/styles';

const theme = unstable_createMuiStrictModeTheme();

function App() {
  return (
    <React.StrictMode>
      <ThemeProvider theme={theme}>
        <LandingPage />
      </ThemeProvider>
    </React.StrictMode>
  );
}

Copy
ThemeProvider

This component takes a theme prop and applies it to the entire React tree that it is wrapping around. It should preferably be used at the root of your component tree.

Props
Name	Type	Description
children *	node	Your component tree.
theme *	union: object | func	A theme object, usually the result of createTheme(). The provided theme will be merged with the default theme. You can provide a function to extend the outer theme.
Examples
import * as React from 'react';
import { red } from '@mui/material/colors';
import { ThemeProvider, createTheme } from '@mui/material/styles';

const theme = createTheme({
  palette: {
    primary: {
      main: red[500],
    },
  },
});

function App() {
  return <ThemeProvider theme={theme}>...</ThemeProvider>;
}

Theming
Customize Material UI with your theme. You can change the colors, the typography and much more.
tidelift
MUI for enterprise. Save time and reduce risk. Managed open source — backed by maintainers.
ad by MUI

The theme specifies the color of the components, darkness of the surfaces, level of shadow, appropriate opacity of ink elements, etc.

Themes let you apply a consistent tone to your app. It allows you to customize all design aspects of your project in order to meet the specific needs of your business or brand.

To promote greater consistency between apps, light and dark theme types are available to choose from. By default, components use the light theme type.

Theme provider

Material UI components adhere to the library's default theme out of the box. Use ThemeProvider to inject a custom theme into your application.

ThemeProvider relies on the context feature of React to pass the theme down to the components, so you need to make sure that ThemeProvider is a parent of the components you are trying to customize. You can learn more about this in the API section.

Theme configuration variables

Changing the theme configuration variables is the most effective way to match Material UI to your needs. The following sections cover the most important theme variables:

.palette
.typography
.spacing
.breakpoints
.zIndex
.transitions
.components
You can check out the default theme section to view the default theme in full.

Custom variables

When using Material UI's theme with MUI System or any other styling solution, it can be convenient to add additional variables to the theme so you can use them everywhere. For instance:

const theme = createTheme({
  status: {
    danger: orange[500],
  },
});

Copy
vars is an autogenerated field for CSS theme variables. It will throw an error if you try to pass a value to it:

createTheme({
  vars: { ... }, // ❌ error
})

Copy
TypeScript

You have to use module augmentation to add new variables to the Theme and ThemeOptions.

declare module '@mui/material/styles' {
  interface Theme {
    status: {
      danger: string;
    };
  }
  // allow configuration using `createTheme()`
  interface ThemeOptions {
    status?: {
      danger?: string;
    };
  }
}

Copy
<ThemeProvider theme={theme}>
  <CustomCheckbox defaultChecked />
</ThemeProvider>
<ThemeProvider theme={theme}>
  <CustomCheckbox defaultChecked />
</ThemeProvider>
Press Enter to start editing
To add extra variables to the theme.palette, see palette customization.

Theme builder

The community has built great tools to build a theme:

mui-theme-creator: A tool to help design and customize themes for the Material UI component library. Includes basic site templates to show various components and how they are affected by the theme
Material palette generator: The Material palette generator can be used to generate a palette for any color you input.
Accessing the theme in a component

You can access the theme variables inside your functional React components using the useTheme hook:

import { useTheme } from '@mui/material/styles';

function DeepChild() {
  const theme = useTheme();
  return <span>{`spacing ${theme.spacing}`}</span>;
}

Copy
Nesting the theme

You can nest multiple theme providers.

<ThemeProvider theme={outerTheme}>
  <Checkbox defaultChecked />
  <ThemeProvider theme={innerTheme}>
    <Checkbox defaultChecked />
  </ThemeProvider>
</ThemeProvider>
<ThemeProvider theme={outerTheme}>
  <Checkbox defaultChecked />
  <ThemeProvider theme={innerTheme}>
    <Checkbox defaultChecked />
  </ThemeProvider>
</ThemeProvider>
Press Enter to start editing
The inner theme will override the outer theme. You can extend the outer theme by providing a function:

CSS theme variables

To generate CSS variables from the theme, set cssVariables to true in the theme configuration and pass it to the ThemeProvider:

const theme = createTheme({
  cssVariables: true,
});

function App() {
  return <ThemeProvider theme={theme}>...</ThemeProvider>;
}

Copy
This generates a global stylesheet with the CSS theme variables:

:root {
  --mui-palette-primary-main: #1976d2;
  /* ...other variables */
}

Copy
All components under the ThemeProvider will use those CSS theme variables instead of raw values.

Button styles
- color: #1976d2;
+ color: var(--mui-palette-primary-main);

Copy
To learn more about this feature, see the CSS theme variables guide.

API

createTheme(options, ...args) => theme

Generate a theme base on the options received. Then, pass it as a prop to ThemeProvider.

Arguments
options (object): Takes an incomplete theme object and adds the missing parts.
...args (object[]): Deep merge the arguments with the about to be returned theme.
Only the first argument (options) is processed by the createTheme() function. While passing multiple arguments currently works for backward compatibility, this behavior may be removed in future versions. To ensure your code remains forward-compatible, you should manually deep merge the theme objects and pass the result as a single object to createTheme().

import { deepmerge } from '@mui/utils';
import { createTheme } from '@mui/material/styles';

const theme = createTheme(deepmerge(options1, options2));

Copy
Returns
theme (object): A complete, ready-to-use theme object.

Examples
import { createTheme } from '@mui/material/styles';
import { green, purple } from '@mui/material/colors';

const theme = createTheme({
  palette: {
    primary: {
      main: purple[500],
    },
    secondary: {
      main: green[500],
    },
  },
});

Copy
Theme composition: using theme options to define other options
When the value for a theme option is dependent on another theme option, you should compose the theme in steps.

import { createTheme } from '@mui/material/styles';

let theme = createTheme({
  palette: {
    primary: {
      main: '#0052cc',
    },
    secondary: {
      main: '#edf2ff',
    },
  },
});

theme = createTheme(theme, {
  palette: {
    info: {
      main: theme.palette.secondary.main,
    },
  },
});

Copy
Think of creating a theme as a two-step composition process: first, you define the basic design options; then, you'll use these design options to compose other options.

WARNING: theme.vars is a private field used for CSS variables support. Please use another name for a custom object.

Merging className and style props in defaultProps

By default, when a component has defaultProps defined in the theme, props passed to the component override the default props completely.

import { createTheme } from '@mui/material/styles';

const theme = createTheme({
  components: {
    MuiButton: {
      defaultProps: {
        className: 'default-button-class',
        style: { marginTop: 8 },
      },
    },
  },
});

// className will be: "custom-button-class" (default ignored)
// style will be: { color: 'blue' } (default ignored)
<Button className="custom-button-class" style={{ color: 'blue' }}>
  Click me
</Button>;

Copy
You can change this behavior by configuring the theme to merge className and style props instead of replacing them.

To do this, set theme.components.mergeClassNameAndStyle to true:

import { createTheme } from '@mui/material/styles';

const theme = createTheme({
  components: {
    mergeClassNameAndStyle: true,
    MuiButton: {
      defaultProps: {
        className: 'default-button-class',
        style: { marginTop: 8 },
      },
    },
  },
});

Copy
Here's what the example above looks like with this configuration:

// className will be: "default-button-class custom-button-class"
// style will be: { marginTop: 8, color: 'blue' }
<Button className="custom-button-class" style={{ color: 'blue' }}>
  Click me
</Button>

Copy
responsiveFontSizes(theme, options) => theme

Generate responsive typography settings based on the options received.

Arguments
theme (object): The theme object to enhance.
options (object [optional]):
breakpoints (array<string> [optional]): Default to ['sm', 'md', 'lg']. Array of breakpoints (identifiers).
disableAlign (bool [optional]): Default to false. Whether font sizes change slightly so line heights are preserved and align to Material Design's 4px line height grid. This requires a unitless line height in the theme's styles.
factor (number [optional]): Default to 2. This value determines the strength of font size resizing. The higher the value, the less difference there is between font sizes on small screens. The lower the value, the bigger font sizes for small screens. The value must be greater than 1.
variants (array<string> [optional]): Default to all. The typography variants to handle.
Returns
theme (object): The new theme with a responsive typography.

Examples
import { createTheme, responsiveFontSizes } from '@mui/material/styles';

let theme = createTheme();
theme = responsiveFontSizes(theme);

Copy
unstable_createMuiStrictModeTheme(options, ...args) => theme

WARNING: Do not use this method in production.

Generates a theme that reduces the amount of warnings inside React.StrictMode like Warning: findDOMNode is deprecated in StrictMode.

Requirements
Currently unstable_createMuiStrictModeTheme adds no additional requirements.

Arguments
options (object): Takes an incomplete theme object and adds the missing parts.
...args (object[]): Deep merge the arguments with the about to be returned theme.
Returns
theme (object): A complete, ready-to-use theme object.

Examples
import { unstable_createMuiStrictModeTheme } from '@mui/material/styles';

const theme = unstable_createMuiStrictModeTheme();

function App() {
  return (
    <React.StrictMode>
      <ThemeProvider theme={theme}>
        <LandingPage />
      </ThemeProvider>
    </React.StrictMode>
  );
}

Copy
ThemeProvider

This component takes a theme prop and applies it to the entire React tree that it is wrapping around. It should preferably be used at the root of your component tree.

Props
Name	Type	Description
children *	node	Your component tree.
theme *	union: object | func	A theme object, usually the result of createTheme(). The provided theme will be merged with the default theme. You can provide a function to extend the outer theme.
Examples
import * as React from 'react';
import { red } from '@mui/material/colors';
import { ThemeProvider, createTheme } from '@mui/material/styles';

const theme = createTheme({
  palette: {
    primary: {
      main: red[500],
    },
  },
});

function App() {
  return <ThemeProvider theme={theme}>...</ThemeProvider>;
}

Creating themed components
Learn how to create fully custom components that accept your app's theme.
Help us keep running
If you don't mind tech-related ads (no tracking or remarketing), and want to keep us running, please whitelist us in your blocker.
Thank you! ❤️

Introduction

Material UI provides a powerful theming feature that lets you add your own components to the theme and treat them as if they're built-in components.

If you are building a component library on top of Material UI, you can follow the step-by-step guide below to create a custom component that is themeable across multiple projects.

Alternatively, you can use the provided template as a starting point for your component.

You don't need to connect your component to the theme if you are only using it in a single project.

Step-by-step guide

This guide will walk you through how to build this statistics component, which accepts the app's theme as though it were a built-in Material UI component:

19,267
Active users / month
1. Create the component slots

Slots let you customize each individual element of the component by targeting its respective name in the theme's styleOverrides and theme's variants.

This statistics component is composed of three slots:

root: the container of the component
value: the number of the statistics
unit: the unit or description of the statistics
Though you can give these slots any names you prefer, we recommend using root for the outermost container element for consistency with the rest of the library.

19,267value
Active users / monthunit
root
Use the styled API with name and slot parameters to create the slots, as shown below:

import * as React from 'react';
import { styled } from '@mui/material/styles';

const StatRoot = styled('div', {
  name: 'MuiStat', // The component name
  slot: 'root', // The slot name
})(({ theme }) => ({
  display: 'flex',
  flexDirection: 'column',
  gap: theme.spacing(0.5),
  padding: theme.spacing(3, 4),
  backgroundColor: theme.palette.background.paper,
  borderRadius: theme.shape.borderRadius,
  boxShadow: theme.shadows[2],
  letterSpacing: '-0.025em',
  fontWeight: 600,
  ...theme.applyStyles('dark', {
    backgroundColor: 'inherit',
  }),
}));

const StatValue = styled('div', {
  name: 'MuiStat',
  slot: 'value',
})(({ theme }) => ({
  ...theme.typography.h3,
}));

const StatUnit = styled('div', {
  name: 'MuiStat',
  slot: 'unit',
})(({ theme }) => ({
  ...theme.typography.body2,
  color: theme.palette.text.secondary,
}));

Copy
2. Create the component

Assemble the component using the slots created in the previous step:

// /path/to/Stat.js
import * as React from 'react';

const StatRoot = styled('div', {
  name: 'MuiStat',
  slot: 'root',
})(…);

const StatValue = styled('div', {
  name: 'MuiStat',
  slot: 'value',
})(…);

const StatUnit = styled('div', {
  name: 'MuiStat',
  slot: 'unit',
})(…);

const Stat = React.forwardRef(function Stat(props, ref) {
  const { value, unit, ...other } = props;

  return (
    <StatRoot ref={ref} {...other}>
      <StatValue>{value}</StatValue>
      <StatUnit>{unit}</StatUnit>
    </StatRoot>
  );
});

export default Stat;

Copy
At this point, you'll be able to apply the theme to the Stat component like this:

import { createTheme } from '@mui/material/styles';

const theme = createTheme({
  components: {
    // the component name defined in the `name` parameter
    // of the `styled` API
    MuiStat: {
      styleOverrides: {
        // the slot name defined in the `slot` and `overridesResolver` parameters
        // of the `styled` API
        root: {
          backgroundColor: '#121212',
        },
        value: {
          color: '#fff',
        },
        unit: {
          color: '#888',
        },
      },
    },
  },
});

Copy
3. Style the slot with ownerState

When you need to style the slot-based props or internal state, wrap them in the ownerState object and pass it to each slot as a prop. The ownerState is a special name that will not spread to the DOM via the styled API.

Add a variant prop to the Stat component and use it to style the root slot, as shown below:

  const Stat = React.forwardRef(function Stat(props, ref) {
+   const { value, unit, variant, ...other } = props;
+
+   const ownerState = { ...props, variant };

    return (
-      <StatRoot ref={ref} {...other}>
-        <StatValue>{value}</StatValue>
-        <StatUnit>{unit}</StatUnit>
-      </StatRoot>
+      <StatRoot ref={ref} ownerState={ownerState} {...other}>
+        <StatValue ownerState={ownerState}>{value}</StatValue>
+        <StatUnit ownerState={ownerState}>{unit}</StatUnit>
+      </StatRoot>
    );
  });

Copy
Then you can read ownerState in the slot to style it based on the variant prop.

  const StatRoot = styled('div', {
    name: 'MuiStat',
    slot: 'root',
-  })(({ theme }) => ({
+  })(({ theme, ownerState }) => ({
    display: 'flex',
    flexDirection: 'column',
    gap: theme.spacing(0.5),
    padding: theme.spacing(3, 4),
    backgroundColor: theme.palette.background.paper,
    borderRadius: theme.shape.borderRadius,
    boxShadow: theme.shadows[2],
    letterSpacing: '-0.025em',
    fontWeight: 600,
    ...theme.applyStyles('dark', {
      backgroundColor: 'inherit',
    }),
+   ...ownerState.variant === 'outlined' && {
+    border: `2px solid ${theme.palette.divider}`,
+   },
  }));

Copy
4. Support theme default props

To customize your component's default props for different projects, you need to use the useThemeProps API.

+ import { useThemeProps } from '@mui/material/styles';

- const Stat = React.forwardRef(function Stat(props, ref) {
+ const Stat = React.forwardRef(function Stat(inProps, ref) {
+   const props = useThemeProps({ props: inProps, name: 'MuiStat' });
    const { value, unit, ...other } = props;

    return (
      <StatRoot ref={ref} {...other}>
        <StatValue>{value}</StatValue>
        <StatUnit>{unit}</StatUnit>
      </StatRoot>
    );
  });

Copy
Then you can customize the default props of your component like this:

import { createTheme } from '@mui/material/styles';

const theme = createTheme({
  components: {
    MuiStat: {
      defaultProps: {
        variant: 'outlined',
      },
    },
  },
});

Copy
TypeScript

If you use TypeScript, you must create interfaces for the component props and ownerState:

interface StatProps {
  value: number | string;
  unit: string;
  variant?: 'outlined';
}

interface StatOwnerState extends StatProps {
  // …key value pairs for the internal state that you want to style the slot
  // but don't want to expose to the users
}

Copy
Then you can use them in the component and slots.

const StatRoot = styled('div', {
  name: 'MuiStat',
  slot: 'root',
})<{ ownerState: StatOwnerState }>(({ theme, ownerState }) => ({
  display: 'flex',
  flexDirection: 'column',
  gap: theme.spacing(0.5),
  padding: theme.spacing(3, 4),
  backgroundColor: theme.palette.background.paper,
  borderRadius: theme.shape.borderRadius,
  boxShadow: theme.shadows[2],
  letterSpacing: '-0.025em',
  fontWeight: 600,
  ...theme.applyStyles('dark', {
    backgroundColor: 'inherit',
  }),
  // typed-safe access to the `variant` prop
  ...(ownerState.variant === 'outlined' && {
    border: `2px solid ${theme.palette.divider}`,
    boxShadow: 'none',
  }),
}));

// …do the same for other slots

const Stat = React.forwardRef<HTMLDivElement, StatProps>(function Stat(inProps, ref) {
  const props = useThemeProps({ props: inProps, name: 'MuiStat' });
  const { value, unit, variant, ...other } = props;

  const ownerState = { ...props, variant };

  return (
    <StatRoot ref={ref} ownerState={ownerState} {...other}>
      <StatValue ownerState={ownerState}>{value}</StatValue>
      <StatUnit ownerState={ownerState}>{unit}</StatUnit>
    </StatRoot>
  );
});

Copy
Finally, add the Stat component to the theme types.

import {
  ComponentsOverrides,
  ComponentsVariants,
  Theme as MuiTheme,
} from '@mui/material/styles';
import { StatProps } from 'path/to/Stat';

type Theme = Omit<MuiTheme, 'components'>;

declare module '@mui/material/styles' {
  interface ComponentNameToClassKey {
    MuiStat: 'root' | 'value' | 'unit';
  }

  interface ComponentsPropsList {
    MuiStat: Partial<StatProps>;
  }

  interface Components {
    MuiStat?: {
      defaultProps?: ComponentsPropsList['MuiStat'];
      styleOverrides?: ComponentsOverrides<Theme>['MuiStat'];
      variants?: ComponentsVariants['MuiStat'];
    };
  }
}

Copy
Template

This template is the final product of the step-by-step guide above, demonstrating how to build a custom component that can be styled with the theme as if it was a built-in component.

1.9M
Favorites
5.1M
Views
import * as React from 'react';
import Stack from '@mui/material/Stack';
import { styled, useThemeProps } from '@mui/material/styles';

export interface StatProps {
  value: number | string;
  unit: string;
  variant?: 'outlined';
}

interface StatOwnerState extends StatProps {
  // …key value pairs for the internal state that you want to style the slot
  // but don't want to expose to the users
}

const StatRoot = styled('div', {
  name: 'MuiStat',
  slot: 'root',
})<{ ownerState: StatOwnerState }>(({ theme }) => ({
  display: 'flex',
  flexDirection: 'column',
  gap: theme.spacing(0.5),
  padding: theme.spacing(3, 4),
  backgroundColor: theme.palette.background.paper,
  borderRadius: theme.shape.borderRadius,
  boxShadow: theme.shadows[2],
  letterSpacing: '-0.025em',
  fontWeight: 600,
  variants: [
    {
      props: {
        variant: 'outlined',
      },
      style: {
        border: `2px solid ${theme.palette.divider}`,
        boxShadow: 'none',
      },
    },
  ],
  ...theme.applyStyles('dark', {
    backgroundColor: 'inherit',
  }),
}));

const StatValue = styled('div', {
  name: 'MuiStat',
  slot: 'value',
})<{ ownerState: StatOwnerState }>(({ theme }) => ({
  ...theme.typography.h3,
}));

const StatUnit = styled('div', {
  name: 'MuiStat',
  slot: 'unit',
})<{ ownerState: StatOwnerState }>(({ theme }) => ({
  ...theme.typography.body2,
  color: theme.palette.text.secondary,
  ...theme.applyStyles('dark', {
    color: 'inherit',
  }),
}));

const Stat = React.forwardRef<HTMLDivElement, StatProps>(
  function Stat(inProps, ref) {
    const props = useThemeProps({ props: inProps, name: 'MuiStat' });
    const { value, unit, variant, ...other } = props;

    const ownerState = { ...props, variant };

    return (
      <StatRoot ref={ref} ownerState={ownerState} {...other}>
        <StatValue ownerState={ownerState}>{value}</StatValue>
        <StatUnit ownerState={ownerState}>{unit}</StatUnit>
      </StatRoot>
    );
  },
);

export default function StatFullTemplate() {
  return (
    <Stack direction="row" spacing={2}>
      <Stat value="1.9M" unit="Favorites" />
      <Stat value="5.1M" unit="Views" variant="outlined" />
    </Stack>
  );
}
Themed components
You can customize a component's styles, default props, and more by using its component key inside the theme.
tidelift
MUI for enterprise. Save time and reduce risk. Managed open source — backed by maintainers.
ad by MUI

The components key in the theme helps to achieve styling consistency across your application. However, the theme isn't tree-shakable, prefer creating new components for heavy customizations.

Theme default props

Every Material UI component has default values for each of its props. To change these default values, use the defaultProps key exposed in the theme's components key:

const theme = createTheme({
  components: {
    // Name of the component
    MuiButtonBase: {
      defaultProps: {
        // The props to change the default for.
        disableRipple: true, // No more ripple, on the whole application 💣!
      },
    },
  },
});

Copy
<ThemeProvider theme={theme}>
  <Button>This button has disabled ripples.</Button>
</ThemeProvider>
<ThemeProvider theme={theme}>
  <Button>This button has disabled ripples.</Button>
</ThemeProvider>
Press Enter to start editing
If you're using TypeScript and lab components, check this article to learn how to override their styles.

Theme style overrides

The theme's styleOverrides key makes it possible to change the default styles of any Material UI component.

styleOverrides requires a slot name as a key (use root to target the outer-most element) and an object with CSS properties as a value. Nested CSS selectors are also supported as values.

const theme = createTheme({
  components: {
    // Name of the component
    MuiButton: {
      styleOverrides: {
        // Name of the slot
        root: {
          // Some CSS
          fontSize: '1rem',
        },
      },
    },
  },
});

Copy
<ThemeProvider theme={theme}>
  <Button>font-size: 1rem</Button>
</ThemeProvider>
<ThemeProvider theme={theme}>
  <Button>font-size: 1rem</Button>
</ThemeProvider>
Press Enter to start editing
Variants

Most components include design-related props that affect their appearance. For example, the Card component supports a variant prop where you can pick outlined as a value that adds a border.

If you want to override styles based on a specific prop, you can use the variants key in the particular slot that contains props and style keys. When the component's props matches, the style will be applied.

Override definitions are specified as an array. Also, ensure that any styles that should take precedence are listed last.

Overriding styles based on existing props
The example below demonstrates the increase of the border thickness of the outlined Card:

const theme = createTheme({
  components: {
    MuiCard: {
      styleOverrides: {
        root: {
          variants: [
            {
              props: { variant: 'outlined' },
              style: {
                borderWidth: '3px',
              },
            },
          ],
        },
      },
    },
  },
});

Copy
Adding styles based on new values
The example below demonstrates the addition of a new variant dashed to the Button component:

const theme = createTheme({
  components: {
    MuiButton: {
      styleOverrides: {
        root: {
          variants: [
            {
              // `dashed` is an example value, it can be any name.
              props: { variant: 'dashed' },
              style: {
                textTransform: 'none',
                border: `2px dashed ${blue[500]}`,
              },
            },
          ],
        },
      },
    },
  },
});

Copy
Overriding styles based on existing and new props
The example below demonstrates the override of styles when the Button's variant is dashed (a new variant) and color is secondary (an existing color):

const theme = createTheme({
  components: {
    MuiButton: {
      styleOverrides: {
        root: {
          variants: [
            {
              props: { variant: 'dashed', color: 'secondary' },
              style: {
                border: `4px dashed ${red[500]}`,
              },
            },
          ],
        },
      },
    },
  },
});

Copy
If you're using TypeScript, you'll need to specify your new variants/colors, using module augmentation.

declare module '@mui/material/Button' {
  interface ButtonPropsVariantOverrides {
    dashed: true;
  }
}

Copy
<ThemeProvider theme={customTheme}>
  <Button variant="dashed" sx={{ m: 1 }}>
    Dashed
  </Button>
  <Button variant="dashed" color="secondary" sx={{ m: 1 }}>
    Secondary
  </Button>
  <Button variant="dashed" size="large" sx={{ m: 1 }}>
    Large
  </Button>
  <Button variant="dashed" color="secondary" size="large" sx={{ m: 1 }}>
    Secondary large
  </Button>
</ThemeProvider>
<ThemeProvider theme={customTheme}>
  <Button variant="dashed" sx={{ m: 1 }}>
    Dashed
  </Button>
  <Button variant="dashed" color="secondary" sx={{ m: 1 }}>
    Secondary
  </Button>
  <Button variant="dashed" size="large" sx={{ m: 1 }}>
    Large
  </Button>
  <Button variant="dashed" color="secondary" size="large" sx={{ m: 1 }}>
    Secondary large
  </Button>
</ThemeProvider>
Press Enter to start editing
The variant props can also be defined as a callback, allowing you to apply styles based on conditions. This is useful for styling when a property does not have a specific value.

const theme = createTheme({
  components: {
    MuiButton: {
      styleOverrides: {
        root: {
          variants: [
            {
              props: (props) =>
                props.variant === 'dashed' && props.color !== 'secondary',
              style: {
                textTransform: 'none',
                border: `2px dashed ${blue[500]}`,
              },
            },
          ],
        },
      },
    },
  },
});

Copy
Slot ownerState callback (deprecated)

Using callback to access slot's ownerState has been deprecated, use variants instead.

 const theme = createTheme({
   components: {
     MuiButton: {
       styleOverrides: {
-        root: ({ ownerState, theme }) => ({ ... }),
+        root: {
+          variants: [...],
         },
       },
     },
   },
 });

Copy
The sx syntax (experimental)

The sx prop acts as a shortcut for defining custom styles that access the theme object. This prop lets you write inline styles using a superset of CSS. Learn more about the concept behind the sx prop and how sx differs from the styled utility.

You can use the sx prop inside the styleOverrides key to modify styles within the theme using shorthand CSS notation. This is especially handy if you're already using the sx prop with your components because you can use the same syntax in your theme and quickly transfer styles between the two.

The sx prop is a stable feature for customizing components since Material UI v5, but it is still considered experimental when used directly inside the theme object.

Status: Completed
const finalTheme = createTheme({
  components: {
    MuiChip: {
      styleOverrides: {
        root: ({ theme }) =>
          theme.unstable_sx({
            px: 1,
            py: 0.25,
            borderRadius: 1,
          }),
        label: {
          padding: 'initial',
        },
        icon: ({ theme }) =>
          theme.unstable_sx({
            mr: 0.5,
            ml: '-2px',
          }),
      },
    },
  },
});

Copy
Specificity

If you use the theming approach to customize the components, you'll still be able to override them using the sx prop as it has a higher CSS specificity, even if you're using the experimental sx syntax within the theme.

Theme variables

Another way to override the look of all component instances is to adjust the theme configuration variables.

const theme = createTheme({
  typography: {
    button: {
      fontSize: '1rem',
    },
  },
});

Copy
<ThemeProvider theme={theme}>
  <Button>font-size: 1rem</Button>
</ThemeProvider>
<ThemeProvider theme={theme}>
  <Button>font-size: 1rem</Button>
</ThemeProvider>
Press Enter to start editing
Palette
The palette enables you to modify the color of the components to suit your brand.
templates
Premium Templates. Start your project with the best templates for admins, dashboards, and more.
ad by MUI

Color tokens

Palette colors are represented by four tokens:

main: The main shade of the color
light: A lighter shade of main
dark: A darker shade of main
contrastText: Text color, intended to contrast with main
Here's how Material UI's default theme defines the primary color tokens:

const primary = {
  main: '#1976d2',
  light: '#42a5f5',
  dark: '#1565c0',
  contrastText: '#fff',
};

Copy
See the Color documentation for details on the Material Design color system.

Default colors

The theme exposes the following default palette colors (accessible under theme.palette.*):

primary - for primary interface elements.
secondary - for secondary interface elements.
error - for elements that the user should be made aware of.
warning - for potentially dangerous actions or important messages.
info - for highlighting neutral information.
success - for indicating the successful completion of an action that the user triggered.
See Material Design's Color System for details on color usage and guidelines.

Values

You can explore the default palette values using the theme explorer, or by opening the dev tools console on this page (window.theme.palette).

Primary

palette.primary.light

#42a5f5

palette.primary.main

#1976d2

palette.primary.dark

#1565c0

Secondary

palette.secondary.light

#ba68c8

palette.secondary.main

#9c27b0

palette.secondary.dark

#7b1fa2

Error

palette.error.light

#ef5350

palette.error.main

#d32f2f

palette.error.dark

#c62828

Warning

palette.warning.light

#ff9800

palette.warning.main

#ed6c02

palette.warning.dark

#e65100

Info

palette.info.light

#03a9f4

palette.info.main

#0288d1

palette.info.dark

#01579b

Success

palette.success.light

#4caf50

palette.success.main

#2e7d32

palette.success.dark

#1b5e20

The default palette uses the shades prefixed with A (A200, etc.) for the secondary palette color, and the un-prefixed shades for the other palette colors.

Customization

You may override the default palette values by including a palette object as part of your theme. If any of the:

.palette.primary
.palette.secondary
.palette.error
.palette.warning
.palette.info
.palette.success
palette color objects are provided, they will replace the default ones.

This can be achieved by either using a color object or by providing the colors directly:

Using a color object
The most direct way to customize a palette color is to import and apply one or more color objects, as shown below:

import * as React from 'react';
import { createTheme, ThemeProvider } from '@mui/material/styles';
import { lime, purple } from '@mui/material/colors';
import Button from '@mui/material/Button';

const theme = createTheme({
  palette: {
    primary: lime,
    secondary: purple,
  },
});

export default function UsingColorObject() {
  return (
    <ThemeProvider theme={theme}>
      <Button variant="contained">Primary</Button>
      <Button variant="contained" color="secondary" sx={{ ml: 2 }}>
        Secondary
      </Button>
    </ThemeProvider>
  );
}
import * as React from 'react';
import { createTheme, ThemeProvider } from '@mui/material/styles';
import { lime, purple } from '@mui/material/colors';
import Button from '@mui/material/Button';

const theme = createTheme({
  palette: {
    primary: lime,
    secondary: purple,
  },
});

export default function UsingColorObject() {
  return (
    <ThemeProvider theme={theme}>
      <Button variant="contained">Primary</Button>
      <Button variant="contained" color="secondary" sx={{ ml: 2 }}>
        Secondary
      </Button>
    </ThemeProvider>
  );
}
Press Enter to start editing
Providing the colors directly
To modify each color directly, provide an object with one or more of the color tokens. Only the main token is required; light, dark, and contrastText are optional, and if not provided, then their values are calculated automatically:

import { createTheme } from '@mui/material/styles';

const theme = createTheme({
  palette: {
    primary: {
      main: '#FF5733',
      // light: will be calculated from palette.primary.main,
      // dark: will be calculated from palette.primary.main,
      // contrastText: will be calculated to contrast with palette.primary.main
    },
    secondary: {
      main: '#E0C2FF',
      light: '#F5EBFF',
      // dark: will be calculated from palette.secondary.main,
      contrastText: '#47008F',
    },
  },
});

Copy
light

main

dark

light

main

dark

Contrast threshold

The contrastText token is calculated using the contrastThreshold value, to maximize the contrast between the background and the text.

A higher contrast threshold value increases the point at which a background color is considered light, and thus given a dark contrastText. Note that the contrast threshold follows a non-linear curve, and defaults to a value of 3 which indicates a minimum contrast ratio of 3:1.

Default contrast threshold
3:1
Higher contrast threshold
4.5:1
Tonal offset

The light and dark tokens are calculated using the tonalOffset value, to shift the main color's luminance. A higher tonal offset value will make light tokens lighter, and dark tokens darker.

This only applies when working with custom colors—it won't have any effect on the default values.

For example, the tonal offset default value 0.2 shifts the luminance by approximately two indexes, so if the main token is blue[500], then the light token would be blue[300] and dark would be blue[700].

The tonal offset value can be either a number between 0 and 1 (which would apply to both light and dark tokens) or an object with light and dark keys specified:

Default tonal offset
0.2
light

main

dark

Higher tonal offset
0.5
light

main

dark

Asymmetric tonal offset
{ light: 0.1, dark: 0.9 }
light

main

dark

Custom colors

Unlike default colors, tokens for custom colors are not automatically calculated.

To add custom colors, you must either provide the tokens manually, or generate them using the augmentColor utility:

Provide tokens manually

The most straightforward approach is to define all tokens—main, light, dark, and contrastText—manually:

import { createTheme } from '@mui/material/styles';

const theme = createTheme({
  palette: {
    ochre: {
      main: '#E3D026',
      light: '#E9DB5D',
      dark: '#A29415',
      contrastText: '#242105',
    },
  },
});

Copy
light

main

dark

The supported color formats are hex, rgb, and hsl. If you want to use other formats, such as oklch, you need to enable the native color feature.

If you need to manipulate colors, @mui/material/styles provides a set of utilities to help with this. The following example uses the alpha() and getContrastRatio() utilities to define tokens using opacity:

import { createTheme, alpha, getContrastRatio } from '@mui/material/styles';

const violetBase = '#7F00FF';
const violetMain = alpha(violetBase, 0.7);

const theme = createTheme({
  palette: {
    violet: {
      main: violetMain,
      light: alpha(violetBase, 0.5),
      dark: alpha(violetBase, 0.9),
      contrastText: getContrastRatio(violetMain, '#fff') > 4.5 ? '#fff' : '#111',
    },
  },
});

Copy
light

main

dark

Generate tokens using augmentColor utility

Alternatively, you can generate the light, dark and contrastText tokens using the palette's augmentColor utility, which is the same function used for the default palette colors. This requires creating the theme in two steps and providing the main token on which the other will be based on:

import { createTheme } from '@mui/material/styles';

let theme = createTheme({
  // Theme customization goes here as usual, including tonalOffset and/or
  // contrastThreshold as the augmentColor() function relies on these
});

theme = createTheme(theme, {
  // Custom colors created with augmentColor go here
  palette: {
    salmon: theme.palette.augmentColor({
      color: {
        main: '#FF5733',
      },
      name: 'salmon',
    }),
  },
});

Copy
light

main

dark

The contrast threshold and tonal offset values will apply for the colors defined using this utility.

Using in components

After adding a custom color, you will be able to use it in components just like you do with default palette colors:

<Button color="custom">

Copy
TypeScript

If you're using TypeScript, then you need to use module augmentation for custom colors.

To add a custom color to the palette, you must add it to the Palette and PaletteOptions interfaces:

declare module '@mui/material/styles' {
  interface Palette {
    custom: Palette['primary'];
  }

  interface PaletteOptions {
    custom?: PaletteOptions['primary'];
  }
}

Copy
To use a custom color for the color prop of a component, you must add it to the component's PropsColorOverrides interface. The example below shows how to do this with a Button component:

declare module '@mui/material/Button' {
  interface ButtonPropsColorOverrides {
    custom: true;
  }
}

Copy
Adding color tokens

To add a new color token, include it in the color's object as follows:

import { createTheme } from '@mui/material/styles';
import { blue } from '@mui/material/colors';

const theme = createTheme({
  palette: {
    primary: {
      light: blue[300],
      main: blue[500],
      dark: blue[700],
      darker: blue[900],
    },
  },
});

Copy
light

main

dark

darker

TypeScript

If you're using TypeScript, then you'll need to use module augmentation to add the new color token to the PaletteColor and SimplePaletteColorOptions interfaces as follows:

declare module '@mui/material/styles' {
  interface PaletteColor {
    darker?: string;
  }

  interface SimplePaletteColorOptions {
    darker?: string;
  }
}

Copy
Non-palette colors

To learn how to add colors outside of theme.palette, see Theming—Custom variables.

Accessibility

To meet the minimum contrast of at least 4.5:1 as defined in WCAG 2.1 Rule 1.4.3, create a custom theme with a contrast threshold value of 4.5 as follows:

import { createTheme } from '@mui/material/styles';

const theme = createTheme({
  palette: {
    contrastThreshold: 4.5,
  },
});

Copy
The contrastThreshold parameter can produce counterproductive results.
Please verify that the APCA color contrast is improved (WCAG 3 will use this new algorithm).

Picking colors

Need inspiration? The Material Design team has built an palette configuration tool to help you.

Color schemes

To add both built-in light and dark color schemes without creating separate themes, use the colorSchemes: { light: true, dark: true }. This generates the default tokens for both color schemes:

import { createTheme } from '@mui/material/styles';

const theme = createTheme({
  colorSchemes: {
    light: true,
    dark: true,
  },
});

Copy
To override the default tokens for each color scheme, use the same palette object as shown below:

const theme = createTheme({
  colorSchemes: {
    light: {
      palette: {
        primary: {
          main: '#FF5733',
        },
        // ...other tokens
      },
    },
    dark: {
      palette: {
        primary: {
          main: '#E0C2FF',
        },
        // ...other tokens
      },
    },
  },
});

Copy
The colorSchemes API is an enhanced version of the palette API, and is the preferred API for this purpose starting from Material UI v6. If you provide both colorSchemes and palette, the latter will override any styles defined in the former.

const theme = createTheme({
  palette: {
    primary: {
      main: '...',
    },
  },
  colorSchemes: {
    light: {
      // This will be replaced by the palette defined above
      palette: {
        primary: {
          main: '...',
        },
      },
    },
    dark: { ... },
  },
});

Copy
Dark mode

For details of how you can set up a dark mode for your theme, head to the dark mode guide.

Typography
The theme provides a set of type sizes that work well together, and also with the layout grid.
tidelift
MUI for enterprise. Save time and reduce risk. Managed open source — backed by maintainers.
ad by MUI

Font family

You can change the font family with the theme.typography.fontFamily property.

For instance, this example uses the system font instead of the default Roboto font:

const theme = createTheme({
  typography: {
    fontFamily: [
      '-apple-system',
      'BlinkMacSystemFont',
      '"Segoe UI"',
      'Roboto',
      '"Helvetica Neue"',
      'Arial',
      'sans-serif',
      '"Apple Color Emoji"',
      '"Segoe UI Emoji"',
      '"Segoe UI Symbol"',
    ].join(','),
  },
});

Copy
Self-hosted fonts

To self-host fonts, download the font files in ttf, woff, and/or woff2 formats and import them into your code.

This requires that you have a plugin or loader in your build process that can handle loading ttf, woff, and woff2 files. Fonts will not be embedded within your bundle. They will be loaded from your webserver instead of a CDN.

import RalewayWoff2 from './fonts/Raleway-Regular.woff2';

Copy
Next, you need to change the theme to use this new font. In order to globally define Raleway as a font face, the CssBaseline component can be used (or any other CSS solution of your choice).

import RalewayWoff2 from './fonts/Raleway-Regular.woff2';

const theme = createTheme({
  typography: {
    fontFamily: 'Raleway, Arial',
  },
  components: {
    MuiCssBaseline: {
      styleOverrides: `
        @font-face {
          font-family: 'Raleway';
          font-style: normal;
          font-display: swap;
          font-weight: 400;
          src: local('Raleway'), local('Raleway-Regular'), url(${RalewayWoff2}) format('woff2');
          unicodeRange: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF;
        }
      `,
    },
  },
});

// ...
return (
  <ThemeProvider theme={theme}>
    <CssBaseline />
    <Box sx={{ fontFamily: 'Raleway' }}>Raleway</Box>
  </ThemeProvider>
);

Copy
Note that if you want to add additional @font-face declarations, you need to use the string CSS template syntax for adding style overrides, so that the previously defined @font-face declarations won't be replaced.

Font size

Material UI uses rem units for the font size. The browser <html> element default font size is 16px, but browsers have an option to change this value, so rem units allow us to accommodate the user's settings, resulting in a better accessibility support. Users change font size settings for all kinds of reasons, from poor eyesight to choosing optimum settings for devices that can be vastly different in size and viewing distance.

To change the font-size of Material UI you can provide a fontSize property. The default value is 14px.

const theme = createTheme({
  typography: {
    // In Chinese and Japanese the characters are usually larger,
    // so a smaller fontsize may be appropriate.
    fontSize: 12,
  },
});

Copy
The computed font size by the browser follows this mathematical equation:

font size calculation
Responsive font sizes

The theme.typography.* variant properties map directly to the generated CSS. You can use media queries inside them:

const baseTheme = createTheme();

const theme = createTheme({
  typography: {
    h3: {
      fontSize: '1.2rem',
      '@media (min-width:600px)': {
        fontSize: '1.5rem',
      },
      [baseTheme.breakpoints.up('md')]: {
        fontSize: '2.4rem',
      },
    },
  },
});

Copy
Responsive h3
<ThemeProvider theme={theme}>
  <Typography variant="h3">Responsive h3</Typography>
</ThemeProvider>
<ThemeProvider theme={theme}>
  <Typography variant="h3">Responsive h3</Typography>
</ThemeProvider>
Press Enter to start editing
To automate this setup, you can use the responsiveFontSizes() helper to make Typography font sizes in the theme responsive.

h1
h2
h3
h4
h5
h6
subtitle1
You can see this in action in the example below. Adjust your browser's window size, and notice how the font size changes as the width crosses the different breakpoints:

import { createTheme, responsiveFontSizes } from '@mui/material/styles';

let theme = createTheme();
theme = responsiveFontSizes(theme);

Copy
Responsive h3
Responsive h4
Responsive h5
<ThemeProvider theme={theme}>
  <Typography variant="h3">Responsive h3</Typography>
  <Typography variant="h4">Responsive h4</Typography>
  <Typography variant="h5">Responsive h5</Typography>
</ThemeProvider>
<ThemeProvider theme={theme}>
  <Typography variant="h3">Responsive h3</Typography>
  <Typography variant="h4">Responsive h4</Typography>
  <Typography variant="h5">Responsive h5</Typography>
</ThemeProvider>
Press Enter to start editing
Fluid font sizes

To be done: #15251.

HTML font size

You might want to change the <html> element default font size. For instance, when using the 10px simplification.

Changing the font size can harm accessibility ♿️. Most browsers agree on the default size of 16px, but the user can change it. For instance, someone with an impaired vision could set their browser's default font size to something larger.

The theme.typography.htmlFontSize property is provided for this use case, which tells Material UI what the font-size on the <html> element is. This is used to adjust the rem value so the calculated font-size always match the specification.

const theme = createTheme({
  typography: {
    // Tell Material UI what the font-size on the html element is.
    htmlFontSize: 10,
  },
});

Copy
html {
  font-size: 62.5%; /* 62.5% of 16px = 10px */
}

Copy
You need to apply the above CSS on the HTML element of this page to see the below demo rendered correctly.

body1

<ThemeProvider theme={theme}>
  <Typography>body1</Typography>
</ThemeProvider>
<ThemeProvider theme={theme}>
  <Typography>body1</Typography>
</ThemeProvider>
Press Enter to start editing
Variants

The typography object comes with 13 variants by default:

h1
h2
h3
h4
h5
h6
subtitle1
subtitle2
body1
body2
button
caption
overline
Each of these variants can be customized individually:

const theme = createTheme({
  typography: {
    subtitle1: {
      fontSize: 12,
    },
    body1: {
      fontWeight: 500,
    },
    button: {
      fontStyle: 'italic',
    },
  },
});

Copy
subtitle
body1

<ThemeProvider theme={theme}>
  <Typography variant="subtitle1">subtitle</Typography>
  <Typography>body1</Typography>
  <Button>Button</Button>
</ThemeProvider>
<ThemeProvider theme={theme}>
  <Typography variant="subtitle1">subtitle</Typography>
  <Typography>body1</Typography>
  <Button>Button</Button>
</ThemeProvider>
Press Enter to start editing
Adding & disabling variants

In addition to using the default typography variants, you can add custom ones, or disable any you don't need. Here is what you need to do:

Step 1. Update the theme's typography object

The code snippet below adds a custom variant to the theme called poster, and removes the default h3 variant:

const theme = createTheme({
  typography: {
    poster: {
      fontSize: '4rem',
      color: 'red',
    },
    // Disable h3 variant
    h3: undefined,
  },
});

Copy
Step 2. (Optional) Set the default semantic element for your new variant

At this point, you can already use the new poster variant, which will render a <span> by default with your custom styles. Sometimes you may want to default to a different HTML element for semantic purposes, or to replace the inline <span> with a block-level element for styling purposes.

To do this, update the variantMapping prop of the Typography component globally, at the theme level:

const theme = createTheme({
  typography: {
    poster: {
      fontSize: 64,
      color: 'red',
    },
    // Disable h3 variant
    h3: undefined,
  },
  components: {
    MuiTypography: {
      defaultProps: {
        variantMapping: {
          // Map the new variant to render a <h1> by default
          poster: 'h1',
        },
      },
    },
  },
});

Copy
Step 3. Update the necessary typings (if you are using TypeScript)

If you aren't using TypeScript you should skip this step.

You need to make sure that the typings for the theme's typography variants and the Typography's variant prop reflects the new set of variants.

declare module '@mui/material/styles' {
  interface TypographyVariants {
    poster: React.CSSProperties;
  }

  // allow configuration using `createTheme()`
  interface TypographyVariantsOptions {
    poster?: React.CSSProperties;
  }
}

// Update the Typography's variant prop options
declare module '@mui/material/Typography' {
  interface TypographyPropsVariantOverrides {
    poster: true;
    h3: false;
  }
}

Copy
Step 4. You can now use the new variant

poster
h3
<Typography variant="poster">poster</Typography>;

/* This variant is no longer supported. If you are using TypeScript it will give an error */
<Typography variant="h3">h3</Typography>;

Copy
Default values

You can explore the default values of the typography using the theme explorer or by opening the dev tools console on this page (window.theme.typography).

Spacing
Use the theme.spacing() helper to create consistent spacing between the elements of your UI.
Help us keep running
If you don't mind tech-related ads (no tracking or remarketing), and want to keep us running, please whitelist us in your blocker.
Thank you! ❤️

Material UI uses a recommended 8px scaling factor by default.

const theme = createTheme();

theme.spacing(2); // `${8 * 2}px` = '16px'

Copy
Custom spacing

You can change the spacing transformation by providing:

a number
const theme = createTheme({
  spacing: 4,
});

theme.spacing(2); // `${4 * 2}px` = '8px'

Copy
a function
const theme = createTheme({
  spacing: (factor) => `${0.25 * factor}rem`, // (Bootstrap strategy)
});

theme.spacing(2); // = 0.25 * 2rem = 0.5rem = 8px

Copy
an array
const theme = createTheme({
  spacing: [0, 4, 8, 16, 32, 64],
});

theme.spacing(2); // = '8px'

Copy
Note that when spacing is defined as an array, it only works with positive integers that will be used as array indexes.
It doesn't support all possible signatures of the theme.spacing() helper, for example theme.spacing(0.5), theme.spacing(-1), or theme.spacing(1, 'auto').

If you must use spacing array, consider using a function signature that can handle all possible signatures of the theme.spacing() helper:

Spacing function example
Multiple arity

The theme.spacing() helper accepts up to 4 arguments. You can use the arguments to reduce the boilerplate.

-padding: `${theme.spacing(1)} ${theme.spacing(2)}`, // '8px 16px'
+padding: theme.spacing(1, 2), // '8px 16px'

Copy
Mixing string values is also supported:

margin: theme.spacing(1, 'auto'), // '8px auto'

Copy
Breakpoints
API that enables the use of breakpoints in a wide variety of contexts.
templates
Premium Templates. Start your project with the best templates for admins, dashboards, and more.
ad by MUI

For optimal user experience, Material Design interfaces need to be able to adapt their layout at various breakpoints. Material UI uses a simplified implementation of the original specification.

The breakpoints are used internally in various components to make them responsive, but you can also take advantage of them for controlling the layout of your application through the Grid component.

Default breakpoints

Each breakpoint (a key) matches with a fixed screen width (a value):

xs, extra-small: 0px
sm, small: 600px
md, medium: 900px
lg, large: 1200px
xl, extra-large: 1536px
These values can be customized.

CSS Media Queries

CSS media queries are the idiomatic approach to make your UI responsive. The theme provides five styles helpers to do so:

theme.breakpoints.up(key)
theme.breakpoints.down(key)
theme.breakpoints.only(key)
theme.breakpoints.not(key)
theme.breakpoints.between(start, end)
In the following demo, we change the background color (red, blue & green) based on the screen width.

const styles = (theme) => ({
  root: {
    padding: theme.spacing(1),
    [theme.breakpoints.down('md')]: {
      backgroundColor: theme.palette.secondary.main,
    },
    [theme.breakpoints.up('md')]: {
      backgroundColor: theme.palette.primary.main,
    },
    [theme.breakpoints.up('lg')]: {
      backgroundColor: green[500],
    },
  },
});

Copy
down(md): red

up(md): blue

up(lg): green

<Root>
  <Typography>down(md): red</Typography>
  <Typography>up(md): blue</Typography>
  <Typography>up(lg): green</Typography>
</Root>
<Root>
  <Typography>down(md): red</Typography>
  <Typography>up(md): blue</Typography>
  <Typography>up(lg): green</Typography>
</Root>
Press Enter to start editing
JavaScript Media Queries

Sometimes, using CSS isn't enough. You might want to change the React rendering tree based on the breakpoint value, in JavaScript.

useMediaQuery hook

You can learn more on the useMediaQuery page.

Custom breakpoints

You define your project's breakpoints in the theme.breakpoints section of your theme.

theme.breakpoints.values: Default to the above values. The keys are your screen names, and the values are the min-width where that breakpoint should start.
theme.breakpoints.unit: Default to 'px'. The unit used for the breakpoint's values.
theme.breakpoints.step: Default to 5. The increment divided by 100 used to implement exclusive breakpoints. For example, { step: 5 } means that down(500) will result in '(max-width: 499.95px)'.
If you change the default breakpoints's values, you need to provide them all:

const theme = createTheme({
  breakpoints: {
    values: {
      xs: 0,
      sm: 600,
      md: 900,
      lg: 1200,
      xl: 1536,
    },
  },
});

Copy
Feel free to have as few or as many breakpoints as you want, naming them in whatever way you'd prefer for your project.

const theme = createTheme({
  breakpoints: {
    values: {
      mobile: 0,
      tablet: 640,
      laptop: 1024,
      desktop: 1200,
    },
  },
});

Copy
If you are using TypeScript, you would also need to use module augmentation for the theme to accept the above values.

declare module '@mui/material/styles' {
  interface BreakpointOverrides {
    xs: false; // removes the `xs` breakpoint
    sm: false;
    md: false;
    lg: false;
    xl: false;
    mobile: true; // adds the `mobile` breakpoint
    tablet: true;
    laptop: true;
    desktop: true;
  }
}

Copy
API

theme.breakpoints.up(key) => media query

Arguments
key (string | number): A breakpoint key (xs, sm, etc.) or a screen width number in px.
Returns
media query: A media query string ready to be used with most styling solutions, which matches screen widths greater than the screen size given by the breakpoint key (inclusive).

Examples
const styles = (theme) => ({
  root: {
    backgroundColor: 'blue',
    // Match [md, ∞)
    //       [900px, ∞)
    [theme.breakpoints.up('md')]: {
      backgroundColor: 'red',
    },
  },
});

Copy
theme.breakpoints.down(key) => media query

Arguments
key (string | number): A breakpoint key (xs, sm, etc.) or a screen width number in px.
Returns
media query: A media query string ready to be used with most styling solutions, which matches screen widths less than the screen size given by the breakpoint key (exclusive).

Examples
const styles = (theme) => ({
  root: {
    backgroundColor: 'blue',
    // Match [0, md)
    //       [0, 900px)
    [theme.breakpoints.down('md')]: {
      backgroundColor: 'red',
    },
  },
});

Copy
theme.breakpoints.only(key) => media query

Arguments
key (string): A breakpoint key (xs, sm, etc.).
Returns
media query: A media query string ready to be used with most styling solutions, which matches screen widths starting from the screen size given by the breakpoint key (inclusive) and stopping at the screen size given by the next breakpoint key (exclusive).

Examples
const styles = (theme) => ({
  root: {
    backgroundColor: 'blue',
    // Match [md, md + 1)
    //       [md, lg)
    //       [900px, 1200px)
    [theme.breakpoints.only('md')]: {
      backgroundColor: 'red',
    },
  },
});

Copy
theme.breakpoints.not(key) => media query

Arguments
key (string): A breakpoint key (xs, sm, etc.).
Returns
media query: A media query string ready to be used with most styling solutions, which matches screen widths stopping at the screen size given by the breakpoint key (exclusive) and starting at the screen size given by the next breakpoint key (inclusive).

Examples
const styles = (theme) => ({
  root: {
    backgroundColor: 'blue',
    // Match [xs, md) and [md + 1, ∞)
    //       [xs, md) and [lg, ∞)
    //       [0px, 900px) and [1200px, ∞)
    [theme.breakpoints.not('md')]: {
      backgroundColor: 'red',
    },
  },
});

Copy
theme.breakpoints.between(start, end) => media query

Arguments
start (string): A breakpoint key (xs, sm, etc.) or a screen width number in px.
end (string): A breakpoint key (xs, sm, etc.) or a screen width number in px.
Returns
media query: A media query string ready to be used with most styling solutions, which matches screen widths greater than the screen size given by the breakpoint key in the first argument (inclusive) and less than the screen size given by the breakpoint key in the second argument (exclusive).

Examples
const styles = (theme) => ({
  root: {
    backgroundColor: 'blue',
    // Match [sm, md)
    //       [600px, 900px)
    [theme.breakpoints.between('sm', 'md')]: {
      backgroundColor: 'red',
    },
  },
});

Copy
Default values

You can explore the default values of the breakpoints using the theme explorer or by opening the dev tools console on this page (window.theme.breakpoints).

Container queries
Material UI provides a utility function for creating CSS container queries based on theme breakpoints.
figma
For Figma. A large UI kit with over 600 handcrafted Material UI, MUI X, Joy UI components 🎨.
ad by MUI

Usage

To create CSS container queries, use theme.containerQueries with any method available in the theme.breakpoints. The value can be unitless (in which case it'll be rendered in pixels), a string, or a breakpoint key. For example:

theme.containerQueries.up('sm'); // => '@container (min-width: 600px)'

Copy
0px350px500px
The house from the offer.
123 Main St, Phoenix AZ
$280,000 — $310,000
Confidence score: 85%
One of the ancestors must have the CSS container type specified.

Named containment contexts

To refer to a containment context, call the containerQueries method with the name of the container for access to all breakpoint methods:

theme.containerQueries('sidebar').up('500px'); // => '@container sidebar (min-width: 500px)'

Copy
Shorthand syntax

When adding styles using the sx prop, use the @<size> or @<size>/<name> notation to apply container queries without referring to the theme.

<size>: a width or a breakpoint key.
<name> (optional): a named containment context.
0px350px500px
The house from the offer.
123 Main St, Phoenix AZ
$280,000 — $310,000
Confidence score: 85%
Caveats

The @ prefix with a unitless value renders as px, so @500 is equivalent to 500px—but @500px is incorrect syntax and won't render correctly.

@ with no number renders as 0px.

Container queries must share the same units (the sizes can be defined in any order), as shown below:

// ✅ These container queries will be sorted correctly.
padding: {
  '@40em': 4,
  '@20em': 2,
  '@': 0,
}

// ❌ These container queries won't be sorted correctly
//    because 40em is typically greater than 50px
//    and the units don't match.
padding: {
  '@40em': 4,
  '@50': 2,
  '@': 0,
}

Copy
API

CSS container queries support all the methods available in the breakpoints API.

// For default breakpoints
theme.containerQueries.up('sm'); // => '@container (min-width: 600px)'
theme.containerQueries.down('md'); // => '@container (max-width: 900px)'
theme.containerQueries.only('md'); // => '@container (min-width: 600px) and (max-width: 900px)'
theme.containerQueries.between('sm', 'lg'); // => '@container (min-width: 600px) and (max-width: 1200px)'
theme.containerQueries.not('sm'); // => '@container (max-width: 600px)'

Copy
Density
How to apply density to Material UI components.
templates
Premium Templates. Start your project with the best templates for admins, dashboards, and more.
ad by MUI

Applying density

This section explains how to apply density. It doesn't cover potential use cases, or considerations for using density in your application. The Material Design guidelines have a comprehensive guide covering these topics in more detail.

Implementing density

Higher density can be applied to some components via props. The component pages have at least one example using the respective component with higher density applied.

Depending on the component, density is applied either via lower spacing, or simply by reducing the size.

The following components have props applying higher density:

Button
Fab
FilledInput
FormControl
FormHelperText
IconButton
InputBase
InputLabel
ListItem
OutlinedInput
Table
TextField
Toolbar
Explore theme density

This tool allows you to apply density via spacing and component props. You can browse around and see how this applies to the overall feel of Material UI components.

If you enable high density a custom theme is applied to the docs. This theme is only for demonstration purposes. You should not apply this theme to your whole application as this might negatively impact user experience. The Material Design guidelines has examples for when not to apply density.

The theme is configured with the following options:

const theme = createTheme({
  components: {
    MuiButton: {
      defaultProps: {
        size: 'small',
      },
    },
    MuiFilledInput: {
      defaultProps: {
        margin: 'dense',
      },
    },
    MuiFormControl: {
      defaultProps: {
        margin: 'dense',
      },
    },
    MuiFormHelperText: {
      defaultProps: {
        margin: 'dense',
      },
    },
    MuiIconButton: {
      defaultProps: {
        size: 'small',
      },
    },
    MuiInputBase: {
      defaultProps: {
        margin: 'dense',
      },
    },
    MuiInputLabel: {
      defaultProps: {
        margin: 'dense',
      },
    },
    MuiListItem: {
      defaultProps: {
        dense: true,
      },
    },
    MuiOutlinedInput: {
      defaultProps: {
        margin: 'dense',
      },
    },
    MuiFab: {
      defaultProps: {
        size: 'small',
      },
    },
    MuiTable: {
      defaultProps: {
        size: 'small',
      },
    },
    MuiTextField: {
      defaultProps: {
        margin: 'dense',
      },
    },
    MuiToolbar: {
      defaultProps: {
        variant: 'dense',
      },
    },
  },
});

Copy
Apply higher density via props
Spacing unit

8
z-index
z-index is the CSS property that helps control layout by providing a third axis to arrange content.
themes
Premium Themes. Kickstart your application development with a ready-made theme.
ad by MUI

Several Material UI components utilize z-index, employing a default z-index scale that has been designed to properly layer drawers, modals, snackbars, tooltips, and more.

The z-index values start at an arbitrary number, high and specific enough to ideally avoid conflicts:

mobile stepper: 1000
fab: 1050
speed dial: 1050
app bar: 1100
drawer: 1200
modal: 1300
snackbar: 1400
tooltip: 1500
These values can always be customized. You will find them in the theme under the zIndex key of the theme. Customization of individual values is discouraged; should you change one, you likely need to change them all.

Transitions
These theme helpers allow you to create custom CSS transitions, you can customize the durations, easings and more.
figma
For Figma. A large UI kit with over 600 handcrafted Material UI, MUI X, Joy UI components 🎨.
ad by MUI

API

theme.transitions.create(props, options) => transition

Arguments
props (string | string[]): Defaults to ['all']. Provides a CSS property, or a list of CSS properties that should be transitioned.
options (object [optional]):
options.duration (string | number [optional]): Defaults to theme.transitions.duration.standard. Provides the duration of the transition.
options.easing (string [optional]): Defaults to theme.transitions.easing.easeInOut. Provides the easing for the transition.
options.delay (string | number [optional]): Defaults to 0. Provides the delay for the transition.
Returns
transition: A CSS transition value, which composes all CSS properties that should be transitioned, together with the defined duration, easing and delay.

Use the theme.transitions.create() helper to create consistent transitions for the elements of your UI.

theme.transitions.create(['background-color', 'transform']);

Copy
Example
theme.transitions.getAutoHeightDuration(height) => duration

Arguments
height (number): The height of the component.
Returns
duration: The calculated duration based on the height.

Durations

You can change some or all of the duration values, or provide your own (for use in the create() helper). This example shows all the default values (in milliseconds), but you only need to provide the keys you wish to change or add.

const theme = createTheme({
  transitions: {
    duration: {
      shortest: 150,
      shorter: 200,
      short: 250,
      // most basic recommended timing
      standard: 300,
      // this is to be used in complex animations
      complex: 375,
      // recommended when something is entering screen
      enteringScreen: 225,
      // recommended when something is leaving screen
      leavingScreen: 195,
    },
  },
});

Copy
Easings

You can change some or all of the easing values, or provide your own, by providing a custom CSS transition-timing-function value.

const theme = createTheme({
  transitions: {
    easing: {
      // This is the most common easing curve.
      easeInOut: 'cubic-bezier(0.4, 0, 0.2, 1)',
      // Objects enter the screen at full velocity from off-screen and
      // slowly decelerate to a resting point.
      easeOut: 'cubic-bezier(0.0, 0, 0.2, 1)',
      // Objects leave the screen at full velocity. They do not decelerate when off-screen.
      easeIn: 'cubic-bezier(0.4, 0, 1, 1)',
      // The sharp curve is used by objects that may return to the screen at any time.
      sharp: 'cubic-bezier(0.4, 0, 0.6, 1)',
    },
  },
});

Copy
References

Check out the Transitions page to explore the transition components that are included with Material UI.

import createPalette from './createPalette';
import createThemeWithVars, {
  CssVarsThemeOptions,
  ColorSystem,
  DefaultColorScheme,
} from './createThemeWithVars';
import createThemeNoVars, { Theme, ThemeOptions } from './createThemeNoVars';

export type { ThemeOptions, Theme, CssThemeVariables } from './createThemeNoVars';

// eslint-disable-next-line consistent-return
function attachColorScheme(
  theme: { colorSchemes?: Partial<Record<string, any>> },
  scheme: 'light' | 'dark',
  colorScheme: boolean | Record<string, any> | undefined,
) {
  if (!theme.colorSchemes) {
    return undefined;
  }
  if (colorScheme) {
    theme.colorSchemes[scheme] = {
      ...(colorScheme !== true && colorScheme),
      palette: createPalette({
        ...(colorScheme === true ? {} : colorScheme.palette),
        mode: scheme,
      } as any), // cast type to skip module augmentation test
    };
  }
}

/**
 * Generate a theme base on the options received.
 * @param options Takes an incomplete theme object and adds the missing parts.
 * @param args Deep merge the arguments with the about to be returned theme.
 * @returns A complete, ready-to-use theme object.
 */
export default function createTheme(
  options: Omit<ThemeOptions, 'components'> &
    Pick<CssVarsThemeOptions, 'defaultColorScheme' | 'colorSchemes' | 'components'> & {
      cssVariables?:
        | boolean
        | Pick<
            CssVarsThemeOptions,
            | 'colorSchemeSelector'
            | 'rootSelector'
            | 'disableCssColorScheme'
            | 'cssVarPrefix'
            | 'shouldSkipGeneratingVar'
            | 'nativeColor'
          >;
    } = {} as any, // cast type to skip module augmentation test
  ...args: object[]
): Theme {
  const {
    palette,
    cssVariables = false,
    colorSchemes: initialColorSchemes = !palette ? { light: true } : undefined,
    defaultColorScheme: initialDefaultColorScheme = palette?.mode,
    ...rest
  } = options;
  const defaultColorSchemeInput = (initialDefaultColorScheme as DefaultColorScheme) || 'light';
  const defaultScheme = initialColorSchemes?.[defaultColorSchemeInput];
  const colorSchemesInput = {
    ...initialColorSchemes,
    ...(palette
      ? {
          [defaultColorSchemeInput]: {
            ...(typeof defaultScheme !== 'boolean' && defaultScheme),
            palette,
          },
        }
      : undefined),
  };

  if (cssVariables === false) {
    if (!('colorSchemes' in options)) {
      // Behaves exactly as v5
      return createThemeNoVars(options as ThemeOptions, ...args);
    }

    let paletteOptions = palette;
    if (!('palette' in options)) {
      if (colorSchemesInput[defaultColorSchemeInput]) {
        if (colorSchemesInput[defaultColorSchemeInput] !== true) {
          paletteOptions = colorSchemesInput[defaultColorSchemeInput].palette;
        } else if (defaultColorSchemeInput === 'dark') {
          // @ts-ignore to prevent the module augmentation test from failing
          paletteOptions = { mode: 'dark' };
        }
      }
    }

    const theme = createThemeNoVars(
      { ...options, palette: paletteOptions } as ThemeOptions,
      ...args,
    ) as unknown as Theme & {
      defaultColorScheme?: 'light' | 'dark';
      colorSchemes?: Partial<Record<string, any>>;
    };

    theme.defaultColorScheme = defaultColorSchemeInput;
    theme.colorSchemes = colorSchemesInput as Record<string, ColorSystem>;

    if (theme.palette.mode === 'light') {
      theme.colorSchemes.light = {
        ...(colorSchemesInput.light !== true && colorSchemesInput.light),
        palette: theme.palette,
      } as ColorSystem;
      attachColorScheme(theme, 'dark', colorSchemesInput.dark);
    }
    if (theme.palette.mode === 'dark') {
      theme.colorSchemes.dark = {
        ...(colorSchemesInput.dark !== true && colorSchemesInput.dark),
        palette: theme.palette,
      } as ColorSystem;
      attachColorScheme(theme, 'light', colorSchemesInput.light);
    }

    return theme;
  }

  if (!palette && !('light' in colorSchemesInput) && defaultColorSchemeInput === 'light') {
    colorSchemesInput.light = true;
  }

  return createThemeWithVars(
    {
      ...rest,
      colorSchemes: colorSchemesInput,
      defaultColorScheme: defaultColorSchemeInput,
      ...(typeof cssVariables !== 'boolean' && cssVariables),
    },
    ...args,
  );
}